<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Numerical Methods Quiz</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
        }
        h2 {
            text-align: center;
            color: #333;
        }
        .question {
            margin-bottom: 20px;
            border: 1px solid #ccc;
            padding: 15px;
            background-color: #fff;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .options {
            margin-left: 20px;
            line-height: 1.6;
        }
        input[type="radio"] {
            margin-right: 10px;
        }
        label {
            cursor: pointer;
        }
        .feedback {
            margin-top: 5px;
            font-weight: bold;
            display: none;
        }
        .correct {
            color: #28a745;
        }
        .incorrect {
            color: #dc3545;
        }
        .explanation {
            color: #555;
            font-style: italic;
            margin-top: 5px;
            display: none;
        }
        #score {
            margin-top: 20px;
            font-weight: bold;
            text-align: center;
            font-size: 1.2em;
            color: #333;
        }
    </style>
</head>
<body>
    <h2>Numerical Methods Quiz</h2>
    <div id="quizContainer"></div>
    <script>
        // Array of 50 questions
        const questions = [
            {
                text: "What is the primary purpose of the Taylor series in numerical methods?",
                options: [
                    "To approximate a function using a polynomial around a specific point",
                    "To solve equations exactly without any approximations",
                    "To remove all computational errors",
                    "To transform functions into linear systems"
                ],
                correctIndex: 0,
                explanation: "The Taylor series approximates a function as a polynomial around a specific point, facilitating numerical computations."
            },
            {
                text: "Which method is commonly used to solve a system of linear equations iteratively?",
                options: [
                    "Newton-Raphson method",
                    "Gauss-Seidel method",
                    "Runge-Kutta method",
                    "Bisection method"
                ],
                correctIndex: 1,
                explanation: "The Gauss-Seidel method is an iterative technique for solving systems of linear equations."
            },
            {
                text: "What does the bisection method require to guarantee convergence?",
                options: [
                    "The function must be differentiable",
                    "The function must change sign over the interval",
                    "The initial guess must be exact",
                    "The function must be linear"
                ],
                correctIndex: 1,
                explanation: "The bisection method requires the function to change sign over the interval to ensure a root exists."
            },
            {
                text: "What is the order of convergence for the Newton-Raphson method under ideal conditions?",
                options: [
                    "Linear",
                    "Quadratic",
                    "Cubic",
                    "Constant"
                ],
                correctIndex: 1,
                explanation: "The Newton-Raphson method has quadratic convergence when the derivative is non-zero at the root."
            },
            {
                text: "In numerical integration, what does the trapezoidal rule approximate?",
                options: [
                    "The derivative of the function",
                    "The area under the curve",
                    "The curvature of the function",
                    "The maximum value of the function"
                ],
                correctIndex: 1,
                explanation: "The trapezoidal rule approximates the area under a curve by summing trapezoids."
            },
            {
                text: "What is the purpose of interpolation in numerical methods?",
                options: [
                    "To estimate values between known data points",
                    "To solve differential equations",
                    "To minimize computational errors",
                    "To extrapolate beyond data points"
                ],
                correctIndex: 0,
                explanation: "Interpolation estimates values between known data points using a fitted function."
            },
            {
                text: "Which of the following is a central difference approximation for the first derivative?",
                options: [
                    "[f(x + h) - f(x)] / h",
                    "[f(x) - f(x - h)] / h",
                    "[f(x + h) - f(x - h)] / (2h)",
                    "[f(x + h) + f(x - h) - 2f(x)] / h²"
                ],
                correctIndex: 2,
                explanation: "The central difference formula [f(x + h) - f(x - h)] / (2h) approximates the first derivative with higher accuracy."
            },
            {
                text: "What is the main difference between truncation error and round-off error?",
                options: [
                    "Truncation error is due to approximating mathematical processes, while round-off error is due to finite precision arithmetic",
                    "Truncation error occurs in iterative methods, while round-off error occurs in direct methods",
                    "Truncation error is always larger than round-off error",
                    "Round-off error can be eliminated by using more terms in the approximation"
                ],
                correctIndex: 0,
                explanation: "Truncation error arises from approximating continuous processes, whereas round-off error comes from the limitations of computer arithmetic."
            },
            {
                text: "Which method is used to decompose a matrix into lower and upper triangular matrices?",
                options: [
                    "Gaussian elimination",
                    "LU decomposition",
                    "Jacobi method",
                    "Power method"
                ],
                correctIndex: 1,
                explanation: "LU decomposition factors a matrix into lower and upper triangular matrices, facilitating the solution of linear systems."
            },
            {
                text: "What is a necessary condition for the Gauss-Seidel method to converge?",
                options: [
                    "The matrix must be symmetric",
                    "The matrix must be diagonally dominant",
                    "The matrix must be singular",
                    "The initial guess must be zero"
                ],
                correctIndex: 1,
                explanation: "For the Gauss-Seidel method to converge, the matrix should be diagonally dominant or positive definite."
            },
            {
                text: "Which method is commonly used to find the largest eigenvalue of a matrix?",
                options: [
                    "Power method",
                    "QR algorithm",
                    "Jacobi method",
                    "Bisection method"
                ],
                correctIndex: 0,
                explanation: "The power method is an iterative technique to find the dominant eigenvalue and its corresponding eigenvector."
            },
            {
                text: "What is the simplest numerical method for solving ordinary differential equations?",
                options: [
                    "Euler's method",
                    "Runge-Kutta method",
                    "Adams-Bashforth method",
                    "Finite element method"
                ],
                correctIndex: 0,
                explanation: "Euler's method is the most straightforward numerical technique for solving ODEs, though it may not be the most accurate."
            },
            {
                text: "What is the order of accuracy for the fourth-order Runge-Kutta method?",
                options: [
                    "First order",
                    "Second order",
                    "Third order",
                    "Fourth order"
                ],
                correctIndex: 3,
                explanation: "The fourth-order Runge-Kutta method has an accuracy of O(h⁴), making it highly precise for solving ODEs."
            },
            {
                text: "What is a stiff differential equation?",
                options: [
                    "An equation that requires a large number of steps to solve",
                    "An equation where certain terms cause rapid changes, challenging numerical stability",
                    "An equation that cannot be solved analytically",
                    "An equation with multiple solutions"
                ],
                correctIndex: 1,
                explanation: "Stiff equations have terms that lead to rapid variations, requiring special numerical methods for stability."
            },
            {
                text: "Which method is commonly used to solve elliptic partial differential equations?",
                options: [
                    "Finite difference method",
                    "Method of characteristics",
                    "Euler's method",
                    "Runge-Kutta method"
                ],
                correctIndex: 0,
                explanation: "The finite difference method is widely used for solving elliptic PDEs by discretizing the domain."
            },
            {
                text: "What is the purpose of the gradient descent method?",
                options: [
                    "To find the maximum of a function",
                    "To find the minimum of a function",
                    "To solve systems of linear equations",
                    "To approximate derivatives"
                ],
                correctIndex: 1,
                explanation: "Gradient descent is an iterative optimization algorithm used to find the minimum of a function."
            },
            {
                text: "What additional information does Newton's method for optimization require compared to the Newton-Raphson method for root finding?",
                options: [
                    "First derivatives",
                    "Second derivatives",
                    "Initial guesses",
                    "Function values only"
                ],
                correctIndex: 1,
                explanation: "Newton's method for optimization requires second derivatives (Hessian matrix), while Newton-Raphson for root finding uses first derivatives."
            },
            {
                text: "What is the least squares method used for?",
                options: [
                    "To find the best-fit line through data points",
                    "To solve systems of linear equations",
                    "To approximate integrals",
                    "To find roots of functions"
                ],
                correctIndex: 0,
                explanation: "The least squares method minimizes the sum of squared residuals to find the best-fit line or curve for data points."
            },
            {
                text: "Which method constructs a single polynomial that passes through all given data points?",
                options: [
                    "Linear regression",
                    "Lagrange interpolation",
                    "Least squares approximation",
                    "Cubic spline interpolation"
                ],
                correctIndex: 1,
                explanation: "Lagrange interpolation creates a single polynomial that exactly fits all data points."
            },
            {
                text: "What is the condition number of a matrix used for?",
                options: [
                    "To determine if the matrix is invertible",
                    "To assess the sensitivity of the solution to perturbations in the data",
                    "To find the rank of the matrix",
                    "To compute the determinant"
                ],
                correctIndex: 1,
                explanation: "The condition number measures how sensitive a solution is to small changes in the input, indicating numerical stability."
            },
            {
                text: "What is the primary cause of round-off errors in numerical computations?",
                options: [
                    "Using approximate methods",
                    "Finite precision of computer arithmetic",
                    "Incorrect algorithm choice",
                    "Insufficient number of iterations"
                ],
                correctIndex: 1,
                explanation: "Round-off errors occur because computers represent numbers with finite precision, leading to small inaccuracies."
            },
            {
                text: "Which method is commonly used to solve two-point boundary value problems?",
                options: [
                    "Shooting method",
                    "Finite element method",
                    "Method of undetermined coefficients",
                    "Separation of variables"
                ],
                correctIndex: 0,
                explanation: "The shooting method converts a boundary value problem into an initial value problem, solvable with ODE methods."
            },
            {
                text: "What is the advantage of adaptive step size in numerical integration?",
                options: [
                    "It reduces computational time by using fewer steps",
                    "It increases accuracy by adjusting the step size based on error estimates",
                    "It eliminates the need for initial conditions",
                    "It simplifies the implementation of the method"
                ],
                correctIndex: 1,
                explanation: "Adaptive step size adjusts dynamically to maintain accuracy while optimizing computational effort."
            },
            {
                text: "What is the Monte Carlo method primarily used for?",
                options: [
                    "Solving differential equations",
                    "Approximating integrals through random sampling",
                    "Finding roots of functions",
                    "Interpolating data points"
                ],
                correctIndex: 1,
                explanation: "Monte Carlo methods use random sampling to estimate numerical results, often for multidimensional integrals."
            },
            {
                text: "What does it mean for a numerical method to be stable?",
                options: [
                    "The method always converges to the exact solution",
                    "Small errors in input do not lead to large errors in output",
                    "The method requires fewer computational resources",
                    "The method can handle any type of function"
                ],
                correctIndex: 1,
                explanation: "Stability ensures that errors do not amplify uncontrollably during computations."
            },
            {
                text: "What is the main advantage of using spline interpolation over polynomial interpolation?",
                options: [
                    "Splines are easier to compute",
                    "Splines avoid Runge's phenomenon of oscillations",
                    "Splines require fewer data points",
                    "Splines are always more accurate"
                ],
                correctIndex: 1,
                explanation: "Spline interpolation reduces oscillations that can occur with high-degree polynomial interpolation."
            },
            {
                text: "Why is numerical differentiation more sensitive to errors than numerical integration?",
                options: [
                    "Differentiation amplifies noise, while integration smooths it",
                    "Integration requires more computational power",
                    "Differentiation is only approximate",
                    "Integration methods are inherently more accurate"
                ],
                correctIndex: 0,
                explanation: "Differentiation amplifies small changes or noise, whereas integration averages out errors."
            },
            {
                text: "What is the finite element method primarily used for?",
                options: [
                    "Solving ordinary differential equations",
                    "Solving partial differential equations by discretizing the domain",
                    "Finding eigenvalues of matrices",
                    "Optimizing functions"
                ],
                correctIndex: 1,
                explanation: "The finite element method discretizes the domain to solve PDEs, widely used in engineering applications."
            },
            {
                text: "What does it mean for a method to have a convergence rate of O(h²)?",
                options: [
                    "The error decreases linearly with step size h",
                    "The error decreases quadratically with step size h",
                    "The method converges in exactly two steps",
                    "The method requires h to be squared"
                ],
                correctIndex: 1,
                explanation: "A convergence rate of O(h²) means halving h reduces the error by a factor of four."
            },
            {
                text: "What is the main disadvantage of the secant method compared to Newton-Raphson?",
                options: [
                    "It requires two initial guesses",
                    "It may converge more slowly",
                    "It does not use derivatives",
                    "It can only find one root at a time"
                ],
                correctIndex: 1,
                explanation: "The secant method typically converges more slowly than Newton-Raphson, though it avoids derivatives."
            },
            {
                text: "What is the purpose of pivoting in Gaussian elimination?",
                options: [
                    "To reduce the number of operations",
                    "To avoid division by zero and improve numerical stability",
                    "To make the matrix symmetric",
                    "To find the determinant"
                ],
                correctIndex: 1,
                explanation: "Pivoting prevents division by small numbers or zero, enhancing stability."
            },
            {
                text: "What is the composite Simpson's rule?",
                options: [
                    "A method that applies Simpson's rule to multiple subintervals",
                    "A method that combines trapezoidal and midpoint rules",
                    "A method for solving differential equations",
                    "A method for finding roots"
                ],
                correctIndex: 0,
                explanation: "The composite Simpson's rule divides the interval into subintervals for improved accuracy."
            },
            {
                text: "What is adaptive quadrature?",
                options: [
                    "A method that adjusts the step size based on the function's behavior",
                    "A method that uses random sampling",
                    "A method that requires the function to be smooth",
                    "A method that only works for polynomials"
                ],
                correctIndex: 0,
                explanation: "Adaptive quadrature adjusts step size dynamically to focus on areas of rapid change."
            },
            {
                text: "What is the conjugate gradient method used for?",
                options: [
                    "Solving systems of nonlinear equations",
                    "Finding minima of quadratic functions",
                    "Interpolating data points",
                    "Approximating integrals"
                ],
                correctIndex: 1,
                explanation: "The conjugate gradient method solves large linear systems and minimizes quadratic functions."
            },
            {
                text: "What is the difference between explicit and implicit methods for solving PDEs?",
                options: [
                    "Explicit methods are always more accurate",
                    "Implicit methods require solving a system of equations at each step",
                    "Explicit methods are only used for linear PDEs",
                    "Implicit methods are computationally cheaper"
                ],
                correctIndex: 1,
                explanation: "Implicit methods involve solving systems of equations, offering better stability."
            },
            {
                text: "Why are iterative methods preferred for solving large sparse linear systems?",
                options: [
                    "They are always faster than direct methods",
                    "They exploit sparsity to reduce memory and computational requirements",
                    "They guarantee exact solutions",
                    "They do not require initial guesses"
                ],
                correctIndex: 1,
                explanation: "Iterative methods leverage sparsity to save memory and computation time."
            },
            {
                text: "What is Hermite interpolation?",
                options: [
                    "Interpolation that matches both function values and derivatives at data points",
                    "Interpolation using piecewise linear functions",
                    "Interpolation that minimizes the maximum error",
                    "Interpolation for periodic functions"
                ],
                correctIndex: 0,
                explanation: "Hermite interpolation matches function values and derivatives for smoother results."
            },
            {
                text: "What is the multidimensional Newton-Raphson method used for?",
                options: [
                    "Solving systems of linear equations",
                    "Solving systems of nonlinear equations",
                    "Finding eigenvalues",
                    "Approximating integrals"
                ],
                correctIndex: 1,
                explanation: "The multidimensional Newton-Raphson method solves nonlinear systems using the Jacobian."
            },
            {
                text: "How can numerical methods handle improper integrals with infinite limits?",
                options: [
                    "By using a change of variables to transform the integral",
                    "By increasing the number of subintervals indefinitely",
                    "By using high-order polynomials",
                    "By applying the trapezoidal rule directly"
                ],
                correctIndex: 0,
                explanation: "Substitution transforms infinite limits into finite ones for numerical integration."
            },
            {
                text: "What is Richardson extrapolation used for?",
                options: [
                    "To improve the accuracy of numerical approximations",
                    "To solve differential equations",
                    "To find roots of functions",
                    "To interpolate data points"
                ],
                correctIndex: 0,
                explanation: "Richardson extrapolation enhances accuracy by combining results from different step sizes."
            },
            {
                text: "What are spectral methods in numerical analysis?",
                options: [
                    "Methods that use eigenvectors to solve problems",
                    "Methods that approximate solutions using global polynomials or trigonometric series",
                    "Methods that rely on random sampling",
                    "Methods for solving linear systems"
                ],
                correctIndex: 1,
                explanation: "Spectral methods use basis functions like Fourier series for high-accuracy solutions."
            },
            {
                text: "What is the main idea behind multigrid methods?",
                options: [
                    "Using multiple grids of different resolutions to accelerate convergence",
                    "Solving problems on a single fine grid",
                    "Applying iterative methods sequentially",
                    "Reducing the problem to a smaller subsystem"
                ],
                correctIndex: 0,
                explanation: "Multigrid methods use coarse and fine grids to efficiently solve large systems."
            },
            {
                text: "What is an ill-conditioned matrix?",
                options: [
                    "A matrix that is nearly singular, making solutions sensitive to perturbations",
                    "A matrix with all zero entries",
                    "A matrix that is not square",
                    "A matrix with a large determinant"
                ],
                correctIndex: 0,
                explanation: "Ill-conditioned matrices have high condition numbers, indicating sensitivity to small changes."
            },
            {
                text: "Why are Chebyshev nodes preferred over equally spaced nodes in polynomial interpolation?",
                options: [
                    "They reduce computational complexity",
                    "They minimize the maximum interpolation error",
                    "They are easier to implement",
                    "They require fewer data points"
                ],
                correctIndex: 1,
                explanation: "Chebyshev nodes minimize the maximum error by distributing points optimally."
            },
            {
                text: "Which formula approximates the second derivative using central differences?",
                options: [
                    "[f(x + h) - 2f(x) + f(x - h)] / h²",
                    "[f(x + h) - f(x - h)] / (2h)",
                    "[f(x) - f(x - h)] / h",
                    "[f(x + h) - f(x)] / h"
                ],
                correctIndex: 0,
                explanation: "The central difference formula for the second derivative is [f(x + h) - 2f(x) + f(x - h)] / h²."
            },
            {
                text: "What is the simplex method used for?",
                options: [
                    "Solving linear programming problems",
                    "Finding roots of nonlinear equations",
                    "Approximating integrals",
                    "Interpolating data"
                ],
                correctIndex: 0,
                explanation: "The simplex method optimizes linear objective functions subject to linear constraints."
            },
            {
                text: "How is the least squares solution for an overdetermined system typically computed?",
                options: [
                    "By solving the normal equations",
                    "By using Gaussian elimination directly",
                    "By applying the bisection method",
                    "By using Euler's method"
                ],
                correctIndex: 0,
                explanation: "The least squares solution for overdetermined systems is found by solving the normal equations."
            },
            {
                text: "What is Gaussian quadrature?",
                options: [
                    "A method that uses equally spaced points for integration",
                    "A method that selects optimal points and weights for high accuracy",
                    "A method that approximates integrals using random sampling",
                    "A method for solving differential equations"
                ],
                correctIndex: 1,
                explanation: "Gaussian quadrature uses optimal points and weights for exact integration of polynomials."
            },
            {
                text: "What is the purpose of Richardson extrapolation in numerical differentiation?",
                options: [
                    "To increase the order of accuracy",
                    "To reduce computational time",
                    "To eliminate the need for step size",
                    "To solve for multiple variables"
                ],
                correctIndex: 0,
                explanation: "Richardson extrapolation improves accuracy by combining approximations with different step sizes."
            },
            {
                text: "What does it mean for an iterative method to be numerically stable?",
                options: [
                    "The method converges to the exact solution",
                    "The method's errors do not grow unboundedly over iterations",
                    "The method requires fewer iterations",
                    "The method can handle any initial guess"
                ],
                correctIndex: 1,
                explanation: "Numerical stability ensures errors remain bounded, allowing convergence or controlled behavior."
            }
        ];

        let score = 0;

        // Function to shuffle an array (Fisher-Yates algorithm)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Function to shuffle options and track the correct answer
        function shuffleOptions(question) {
            const options = [...question.options];
            const correctAnswer = options[question.correctIndex];
            shuffleArray(options);
            const newCorrectIndex = options.indexOf(correctAnswer);
            return { shuffledOptions: options, newCorrectIndex };
        }

        // Generate quiz HTML
        let quizHTML = '';
        questions.forEach((q, index) => {
            const questionNumber = index + 1;
            const { shuffledOptions, newCorrectIndex } = shuffleOptions(q);
            const correctLetter = String.fromCharCode(65 + newCorrectIndex);
            quizHTML += `
                <div class="question" id="q${questionNumber}" data-correct-letter="${correctLetter}">
                    <p>${questionNumber}. ${q.text}</p>
                    <div class="options">
                        ${shuffledOptions.map((opt, i) => `
                            <div>
                                <label>
                                    <input type="radio" name="q${questionNumber}" value="${String.fromCharCode(65 + i)}" onchange="checkAnswer(${questionNumber}, this.value)">
                                    ${String.fromCharCode(65 + i)}. ${opt}
                                </label>
                            </div>
                        `).join('')}
                    </div>
                    <p class="feedback" id="feedback${questionNumber}"></p>
                    <p class="explanation" id="exp${questionNumber}">${q.explanation}</p>
                </div>
            `;
        });
        quizHTML += `<p id="score">Score: ${score}/${questions.length}</p>`;
        document.getElementById('quizContainer').innerHTML = quizHTML;

        // Function to check the user's answer
        function checkAnswer(questionNumber, selectedLetter) {
            const questionDiv = document.getElementById(`q${questionNumber}`);
            const correctLetter = questionDiv.getAttribute('data-correct-letter');
            const feedback = document.getElementById(`feedback${questionNumber}`);
            const explanation = document.getElementById(`exp${questionNumber}`);

            // Adjust score if the question was previously answered
            if (feedback.classList.contains('counted')) {
                if (feedback.innerHTML.includes('Correct')) {
                    score--;
                }
                feedback.classList.remove('counted');
            }

            // Check the answer and provide feedback
            if (selectedLetter === correctLetter) {
                feedback.innerHTML = '<span class="correct">Correct!</span>';
                feedback.style.display = 'block';
                explanation.style.display = 'none';
                score++;
                feedback.classList.add('counted');
            } else {
                feedback.innerHTML = `<span class="incorrect">Incorrect. The correct answer is ${correctLetter}.</span>`;
                feedback.style.display = 'block';
                explanation.style.display = 'block';
                feedback.classList.add('counted');
            }

            // Update the displayed score
            document.getElementById('score').textContent = `Score: ${score}/${questions.length}`;
        }
    </script>
</body>
</html>
